// 命盤解析功能
function parseChart(text) {
    const data = {
        basicInfo: {},
        palaces: {},
        birthYear: null
    };

    parseBasicInfo(text, data);
    parsePalaces(text, data);
    
    return data;
}

function parseBasicInfo(text, data) {
    // 基本資訊解析邏輯
    const genderMatch = text.match(/性别\s*:\s*(\S+)/);
    if (genderMatch) data.basicInfo.gender = genderMatch[1];

    const timeMatch = text.match(/鐘錶時間\s*:\s*([^\n]+)/);
    if (timeMatch) data.basicInfo.birthTime = timeMatch[1].trim();

    const lunarMatch = text.match(/農曆時間\s*:\s*([^\n]+)/);
    if (lunarMatch) data.basicInfo.lunarTime = lunarMatch[1].trim();

    const yearMatch = text.match(/(\d{4})-\d{1,2}-\d{1,2}/);
    if (yearMatch) data.birthYear = parseInt(yearMatch[1]);

    const wuxingMatch = text.match(/五行局數\s*:\s*([^\n]+)/);
    if (wuxingMatch) data.basicInfo.wuxing = wuxingMatch[1].trim();

    const masterMatch = text.match(/身主:([^;]+);\s*命主:([^;]+);\s*子年斗君:([^;]+);\s*身宮:(\S+)/);
    if (masterMatch) {
        data.basicInfo.bodyMaster = masterMatch[1].trim();
        data.basicInfo.lifeMaster = masterMatch[2].trim();
        data.basicInfo.childYearJun = masterMatch[3].trim();
        data.basicInfo.bodyPalace = masterMatch[4].trim();
    }
}

function parsePalaces(text, data) {
    // 宮位解析邏輯 (簡化版，完整版請參考原始代碼)
    const palaceMatches = [];
    const lines = text.split('\n');
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        const palaceMatch = line.match(/├([^宮]*宮)\[([^\]]+)\]/) || line.match(/└([^宮]*宮)\[([^\]]+)\]/);
        if (palaceMatch) {
            const palaceName = palaceMatch[1].trim().replace(/\s+/g, '');
            palaceMatches.push({
                lineIndex: i,
                name: palaceName,
                earthBranch: palaceMatch[2],
                line: line
            });
        }
    }
    
    for (let i = 0; i < palaceMatches.length; i++) {
        const palace = palaceMatches[i];
        const nextPalace = palaceMatches[i + 1];
        
        const startLine = palace.lineIndex + 1;
        const endLine = nextPalace ? nextPalace.lineIndex : lines.length;
        
        let palaceContent = '';
        for (let j = startLine; j < endLine; j++) {
            if (j < lines.length) {
                palaceContent += lines[j] + '\n';
            }
        }
        
        processPalace(palace.name, palace.earthBranch, palaceContent, data);
    }
}

function processPalace(palaceName, earthBranch, content, data) {
    // 宮位處理邏輯 (請根據原始代碼完善)
    const palace = {
        earthBranch: earthBranch,
        mainStars: [],
        supportStars: [],
        minorStars: [],
        birthYearTransforms: [],
        selfTransforms: [],
        flyInTransforms: [],
        majorLimit: {},
        minorLimit: [],
        fluentYear: []
    };
    
    data.palaces[palaceName] = palace;
}
